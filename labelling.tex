\documentclass[kpfonts]{patmorin}
\usepackage{pat}
\usepackage{paralist}
\usepackage{dsfont}  % for \mathds{A}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}

\newcommand{\snote}[1]{\fcolorbox{red}{yellow}{#1}}
\newcommand{\pnote}[1]{\ \newline\noindent\fcolorbox{red}{yellow}{\begin{minipage}{\textwidth}#1\end{minipage}}}
\setlength{\parskip}{1ex}

\DeclareMathOperator{\A}{\mathds{A}}
\DeclareMathOperator{\sn}{sn}
\DeclareMathOperator{\qn}{qn}

\renewcommand{\SS}{\mathcal{S}}


\newcommand{\aref}[1]{(X\ref{a:#1})}
\newcommand{\alabel}[1]{\label{a:#1}}

\title{\MakeUppercase{Optimal Adjacency-Labelling Schemes for Planar Graphs}}
\author{Barbados Folks}

\begin{document}
\begin{titlepage}
\maketitle

\begin{abstract}
  We describe an adjacency labelling-scheme for $n$-vertex planar graphs that assings each vertex a label of length $\log n+o(\log n)$.
\end{abstract}
\end{titlepage}
\pagenumbering{roman}
\tableofcontents

\newpage

\setcounter{page}{0}
\pagenumbering{arabic}
\section{Introduction}

We show that there exists an adjacency labelling scheme for planar graphs where each vertex of an $n$-vertex planar graph is assigned a $(\log n+o(\log n))$-bit label.  This is optimal up to the lower-order term.


\subsection{Proof Overview}

Like Bonamy \etal\ \cite{bonamy.gavoille.ea:shorter}.  Our starting point is a recent result that characterizes planar graphs in terms of the strong product of two simpler graphs.  The \emph{strong product} $A\boxtimes B$ of two graphs $A$ and $B$ is the graph whose vertex set is the Cartesian product $V(A\boxtimes B):=V(A)\times V(B)$ and in which two vertices $v_1:=(x_1,y_1)$ and $v_2:=(x_2,y_2)$ are adjacent if and only if:
\begin{enumerate}
  \item  $v_1\neq v_2$; and
  \item $x_1=x_2$ or $x_1x_2\in E(A)$; and
  \item $y_1=y_2$ or $y_1y_2\in E(B)$.
\end{enumerate}

\begin{thm}[DujmoviÄ‡ \etal \cite{dujmovic.joret.ea:planar}]
  Every planar graph $G$ is the subgraph of a strong product $G^+:=H\boxtimes P$ where $H$ is a graph of treewidth at most 8 and $P$ is a path.
\end{thm}

For graph products like $G^+$, there is a natural labelling scheme: Computer a labelling scheme $\alpha:V(H)\to\{0,1\}^*$ for $H$ and a labelling scheme $\beta:V(P)\to\{0,1\}^*$ for $P$ and assign each vertex $v:=(x,y)\in V(G^*)$ the label $\mu(v):=\alpha(x),\beta(y)$.  Given two labels $\ell_1=\alpha(x_1),\beta(y_1)$ and $\ell_2=\alpha(x_2),\beta(y_2)$ for vertices $v_1=(x_1,y_1)$ and $v_2=(x_2,y_2)$ adjacency testing is done using the following formula whose three clauses follow from definition of strong product:
\[
    L(\ell_1,\ell_2):= (\ell_1\neq \ell_2) \wedge \A(\alpha(x_1),\alpha(x_2)) \wedge \A(\beta(y_1),\beta(y_2)) \enspace .
\]

\ldots



\section{Preliminaries}

For a graph $G$, we use $V(G)$ and $E(G)$ to denote the vertex and edge sets of $G$.  We use $|G|$ as a shorthand for $|V(G)|$.

For a string $s=s_1,\ldots,s_k$, we use $|s|:=k$ to denote the length of $s$. A string $s_1,\ldots,s_k$ is \emph{prefix} of a string $t_1,\ldots,t_\ell$ if $k\le \ell$ and $s_1,\ldots,s_k=t_1,\ldots,t_k$.  A \emph{prefix-free code} $c:X\to\{0,1\}^*$ is a one-to-one function in which $c(x)$ is not a prefix of $c(y)$ for any two distinct $x,y\in X$.  Let $\N$ denote the set of non-negative integers.  The following is an old result of Elias:

\begin{lem}[Elias \cite{elias:universal}]
    There exist a prefix-free code $\gamma:\N\to\{0,1\}^*$ such that, for each $i\in\N$, $|\gamma(i)|\le \log(i+1)+O(\log\log i)$.
\end{lem}

A \emph{binary tree} $T$ is a rooted binary tree in which each node except the root is either the \emph{left} or \emph{right} child of its parent and each node has at most one left and at most one right child.  The \emph{depth} $d_T(v)$ of a node $v$ in a binary tree is the length of the unique path from the root of $T$ to $v$.  The \emph{height} of $T$ is $h(T):=\max_{v\in V(T)} d_T(v)$.

Let $T$ be a binary tree and let $v_0,\ldots,v_{r}$ be a path from the root $v_0$ of $T$ to some node $v_r$ (possibly $r=0$).  Then the \emph{signature} of $v_r$ in $T$, denoted $\sigma_T(v_r)$ is a binary string $b_1,\ldots,b_r$ where $b_i=0$ if and only if $v_{i}$ is the left child of $v_{i-1}$.  (Note that the signature of the root $v_0$ of $T$ is the empty string,  $\sigma_T(v_0)=\varepsilon$.)

A \emph{binary search tree (BST)} $T$ is a binary tree  whose node set $V(T)\subset\R$ consists of numbers and that has the \emph{BST property}:  For each node $x$ that is a left-child of its parent $p$, $x<p$ and for each node $y$ that is a right-child of its parent $p$, $p<y$.  The following observation allows us to replace (possibly large) numbers with (potentially shorter) binary strings:

\begin{obs}\obslabel{lexicographic}
  If $T$ is a binary search tree then, for any $x,y\in V(T)$, $x<y$ if and only if $\sigma_T(x)$ is lexicographically less than $\sigma_T(y)$.
\end{obs}

Let $\R^+$ denote the set of positive real numbers. The following is an easy and often-used result about biased binary search trees:

\begin{lem}\lemlabel{biased-bst}
  For any function $w:\{1,\ldots,n\}\to\R^+$, there exists a binary search tree $T$ containing $\{1,\ldots,n\}$ such that, for each $i\in\{1,\ldots,n\}$, $d_T(i)\le\log(W/w(i))$, where $W:=\sum_{i=1}^n w(i)$.
\end{lem}

To construct the tree in \lemref{biased-bst}, choose the root of $T$ to be the unique node $x\in\{1,\ldots,n\}$ such that $\sum_{z=1}^{x-1} w(i)\le W/2$ and $\sum_{z=x+1}^{n} w(i)< W/2$.  Then recurse on $\{1,\ldots,x-1\}$ and $\{x+1,\ldots,n\}$ to obtain the left and right subtrees respectively.

The following fact about binary search trees is useful, for example, in the deletion algorithms for binary search trees:

\begin{lem}\lemlabel{predecessor-encoding}
  Let $T$ be a binary search tree and let $x,y\in V(T)$ be such that $x<y$ and there is no node $z\in V(T)$ such that $x<z<y$ (i.e., $x$ and $y$ are consecutive in the sorted order of $V(T)$).  Then
  \begin{enumerate}
    \item (if $x$ has no left child) $\sigma_T(y)$ is obtained from $\sigma_T(x)$ by removing all trailing 0's and the last 1; or
    \item (if $x$ has a left child) $\sigma_T(y)$ is obtained from $\sigma_T(x)$ by appending a 0 followed by $s:=d_T(y)-d_T(x)-1$ 1's.
  \end{enumerate}
\end{lem}

Putting the a few of the preceding results together we obtain the following useful coding result:

\begin{lem}\lemlabel{row-code}
  The exists a function $A:(\{0,1\}^*)^2\to\{-1,1,\perp\}$ such that, for any $h\in\N$, and any $w:\{1,\ldots,h\}\to\R^+$ there is a prefix-free code $\alpha:\{1,\ldots,h\}\to \{0,1\}^*$ such that 
  \begin{compactenum}
    \item for each $i\in\{1,\ldots,h\}$, $|\alpha(i)|=\log W -\log w(i) + O(\log\log h)$; and
    \item for each distinct $i,j\in\{1,\ldots,h\}$, 
    \[   A(\alpha(i),\alpha(j)) 
    = \begin{cases}
       1 & \text{if $j=i+1$} \\
       -1 & \text{if $j=i-1$} \\
       \perp & \text{otherwise}
      \end{cases}
      \]
    \end{compactenum}
\end{lem}


\begin{proof}
  Define $w':\{1,\ldots,h\}\to \R^+$ as $w'(i)=w(i)+W/h$ and let $W':=\sum_{i=1}^h w'(i)=2W$.
  Using \lemref{biased-bst}, construct a biased binary search tree $T$ on $\{1,\ldots,h\}$ using $w'$ so that 
  \[   
    d_T(i)\le\log (2W)-\log(w(i)+W/h) \le \log W-\log w(i)+1 \enspace .
  \]
  Also
  \[
  d_T(i)\le\log (2W)-\log(w(i)+W/h) \le \log W-\log (W/h)+1 \le \log h + 1\enspace .
  \]
  for each $i\in\{1,\ldots,h\}$.  The code $\alpha(i$) for $i$ consists of three parts.  The first part, $\gamma(|\sigma_T(i)|)$, encodes the length of the path from the root to $i$ in $T$. The second part $\sigma_T(i)$ encodes the left/right turns along this path.  
  
  The third part $\delta(i)$ of $\alpha(i)$ is the encoding implicit in \lemref{predecessor-encoding}.  That is $\delta(i)$ consists of
  a single bit indicating whether $i$ has a left-child in $T$ and, in case $i$ does have a left-child, an Elias encoding of the value $s=d_T(i-i)-d_T(i)-1$.  More precisely, $\delta(i)=0$ or $\delta(i)=1,\gamma(s)$.  The length of $\delta(i)$ is at most $1+O(\log(s+1))=O(\log\log h)$.

  The function $A$ is now given by a simple algorithm: Given $\alpha(i)$ and $\alpha(j)$ we extract and lexicographically compare $\sigma_T(i)$ and $\sigma_T(j)$.  Assume, for now that $\sigma_T(i)$ is lexicographically less than $\sigma_T(j)$ so that, by \obsref{lexicographic}, $i < j$.  Now using $\sigma_T(j)$ and $\delta(j)$, compute $\sigma_T(j-1)$.  If $\sigma_T(j-1)=\sigma_T(i)$ then output $1$, otherwise output $\perp$.
  In the case where $\sigma_T(i)$ is lexicographically greater than $\sigma_T(j)$ we proceed in the same manner, but reversing the roles of $i$ and $j$ and outputting $-1$ in the case where $\sigma_T(i-1)=\sigma_T(j)$.
\end{proof}

\section{Subgraphs of $P\boxtimes P$}

We begin with the special case where $G\subseteq P_1\boxtimes P_2$ is an $n$-vertex graph where $P_1=1,\ldots,m$ and $P_2=1,\ldots,h$ are paths, so that each vertex of $G$ is a pair $(x,y)\in\{1,\ldots,m\}\times \{1,\ldots,h\}$. 

\pnote{TODO: Annoyingly, it makes sense to (again) reverse the roles of $x$ and $y$ so that, in $H\boxtimes P$, $x\in V(H)$ and $y\in V(P)$. }

For each $x\in\{1,\ldots,m\}$, we let $L_x=\{y:(x,y)\in V(G)\}$.  The idea behind our approach is to have a sequence $T_1,\ldots,T_m$ of balanced binary search trees where, for each $x\in\{1,\ldots,h\}$,
\begin{enumerate}[(PR1)]
  \item $T_x$ contains (a superset of) $\bigcup_{b\in\{-1,0,1\}} (L_{x+b}\cup \{y-1:y\in L_{x+b}\})$;
  \item The height $h(T_x)$ of $T_x$ is $\log |T_x| + o(\log n)$;
  \item $W:=\sum_{x=1}^h |T_x| = O(n)$;
  \item If $y\in V(T_x)\cap V(T_{x+1})$, then $\sigma_{T_{x+1}}(y)$ can be obtained from $\sigma_{T_{x}}(y)$ with an additional $o(\log n)$ bits that we denote by $\nu_x(y)$.  More precisely, there is a (universal) function $B:(\{0,1\}^*)^2\to\{0,1\}^*$ such that $B(\sigma_{T_{x}}(y), \nu_x(y))=\sigma_{T_{x+1}}(y)$
\end{enumerate}

Before describing the sequence of trees satisfying (PR1--4), we show how these can be used in a labelling scheme for $G$. 

Given $G$ and $T_{1},\ldots,T_m$ we use \lemref{row-code} with the weight function $w(x):=|T_x|$ to construct a code $\alpha:\{1,\ldots,m\}\to\{0,1\}^*$ where
\[  
  |\alpha(x)| = \log W-\log|T_x| + O(\log\log m) = \log n - \log|T_x| + o(\log n)
\]
for each $y\in\{1,\ldots,h\}$.  Every vertex $v=(x,y)\in V(G)$ receives a label consisting of the following:  
\begin{enumerate}
  \item $\alpha(x)$;
  \item $\gamma(|\sigma_{T_x}(y)|)$ and $\sigma_{T_x}(y)$;    
  \item $\delta_{T_x}(y)$;
  \item $\nu_x(y)$; and
  \item an array $a(v)$ of $8$ bits indicating whether each of the edges between $(x,y)$ and $(x\pm 1,y\pm 1)$ are present in $G$.  (Note that some of these 8 vertices may not even be present in $G$ in which case the resulting bit is set to 0 since the edge is not present in $G$.)
\end{enumerate}
The two major components of this label are $\alpha(x)$ and $\sigma_{T_x}(y)$ which, together have length $\log n + o(\log n)$.  The three remaining components each have size $o(\log n)$.

Given the labels of $w_1=(x_1,y_1)$ and $w_2=(x_2,y_2)$ we can test if they are adjacent as follows: Using \lemref{row-code} with $\alpha(x_1)$ and $\alpha(x_2)$, determine which of the following applies:
\begin{enumerate}
  \item $|x_1-x_2|\ge 2$: In this case we immediately conclude that $w_1$ and $w_2$ are not adjacent since $x_1x_2\not\in E(H)$.  
  
  \item $x_1=x_2$: In this case, let $x:=x_1=x_2$, let $T:=T_x$ and lexicographically compare $\sigma_T(y_1)$ and $\sigma_T(y_2)$ to determine (without loss of generality) that $y_1<y_2$.  Using $\sigma_{T}(y_2)$ and $\delta_{T}(y_2)$, compute $\delta_{T}(y_2-1)$.  If $\delta_{T}(y_2-1)\neq \delta_T(y_1)$ then immediately conclude that $w_1$ and $w_2$ are not adjacent, since $y_1y_2\not\in E(P)$.  Otherwise, we know that $y_1=y_2-1$ and $x_1=x_2$ so use the relevant bit of $a(w_1)$ (or $a(w_2)$) to determine if $w_1$ and $w_2$ are adjacent in $G$.
  
  \item $x_1=x_2-1$: In this case, use $\sigma_{T_{x_1}}(y_1)$ and $\nu_{x_1}(y_1)$ to compute $\sigma_{T_{x_2}}(y_1)$.  Now let $y:=y_2$, let $T:=T_{y}$, and proceed as in the previous case (but consulting a different bit of $a(w_1)$ in the last step.)
  
  \item $x_2=x_1-1$: In this case, use $\sigma_{T_{x_2}}(y_2)$ and $\nu_{x_2}(y_2)$ to compute $\sigma_{T_{x_1}}(y_2)$.  Now let $x:=x_1$, $T:=T_{x}$, and proceed as in the previous case (but consulting a different bit of $a(w_1)$ in the last step.)
\end{enumerate}

Thus, all that remains is to find a sequence of binary search trees $T_1,\ldots,T_m$ with properties (PR1)--(PR4). This is a data structuring problem and we use a combination of existing and new techniques from data structures to solve it.

\subsection{Fractional Cascading}

Ultimately, we want to reach a point where, for each $x\in\{1,\ldots,m-1\}$ and each $y\in V(T_x)\cap V(T_{x+1})$, the difference between $\sigma_{T_x}(y)$ and $\sigma_{T_{x+1}}(y)$ has a description $\nu_x(y)$ of length $o(\log n)$.  In order for this to be possible, we require that $V(T_x):= L_x$ not be wildly different from $V(T_{x+1}):= L_{x+1}$.  In the world of data structures, this is achieved by the technique of \emph{fractional cascading} \cite{chazelle.guibas:fractional1, chazelle.guibas:fractional2}.

For non-empty sets $X,Y\subset \R$ and an integer $a$, we say that $X$ \emph{$a$-chunks} $Y$ if, for any $a+1$-element subset $S\subseteq Y$, there exists $x\in X$, such that $\min(S)\le x\le \max(S)$. Observe that, if $X$ $a$-chunks $Y$, then $|Y|\le a(|X|+1)\le 2a|X|$.

For each $x\in\{1,\ldots,m\}$, let $L^-_x:=L_x\cup \{y-1:y\in L_x\}$ and observe that $|L^-_x|\le 2|L_y|$, so $\sum_{x=1}^m|L^-_x| \le 2n$.  The following lemma is a form of fractional cascading:

\begin{lem}\lemlabel{fractional}
  There exists universal constants $a,b\ge 1$ and sets $V_1,\ldots,V_m$ such that
  \begin{compactenum}
    \item for each $x\in\{1,\ldots,m\}$, $V_m\supseteq L^-_m$;
    \item for each $x\in\{1,\ldots,m-1\}$, $V_x\cap V_{x+1}$ $a$-chunks $V_{x+1}\setminus V_x$ and $V_x\setminus V_{x+1}$; and
    \item $\sum_{x=1}^m |V_x|\le bn$.
  \end{compactenum}
\end{lem}

Condition~2 in \lemref{fractional} has the following interpretation:  If we sort $V_x\cup V_{x+1}$, then we never see more than $a$ consecutive elements that only belong only to $V_x$ nor do we ever see more than $a$ consecutive elements that belong only to $V_{x+1}$.

We will use \lemref{fractional} to creating the sequence of binary search trees $T_1,\ldots,T_m$ where $V(T_x)=V_x$ for each $x\in\{1,\ldots,m\}$.  Condition~2 in \lemref{fractional} is what will ultimately make it possible to have $T_x$ and $T_{x+1}$ sufficiently similar so that, for any $y\in V_x\cap V_{x+1}$, there will be an $o(\log n)$-bit description $\nu_x(y)$ of how to modify $\sigma_{T_x}(y)$ in order to obtain $\sigma_{T_{x+1}}(y)$.

\subsection{Bulk Deletions}

\begin{lem}\lemlabel{deletion-prefix}
  For any binary search tree $T$ and any $Y\subseteq V(T)$, there exists a binary search tree $T'$ with $V(T')=V(T)\setminus Y$ such that, for every $y\in V(T')$, $\sigma_{T'}(y)$ is a prefix of $\sigma_{T}(y)$.
\end{lem}

\begin{proof}
  It suffices to prove this for a singleton set $Y$ containing one element $z$ since, for larger $Y$ we can remove the values from $T$ one at a time.  The correctness of this follows from the transitivity of the ``is a prefix of'' relation on strings.
  
  The proof is by induction on $|T|$. If $|T|=1$, then the claim is vacuous since $V(T')=\emptyset$.  Therefore assume $|T|\ge 2$.  If $z$ is leaf in $T$, then use $T'=T-\{z\}$ and the result is trivial: $\sigma_{T'}(y)=\sigma_T(y)$ for every $y\in V(T')$.  
  
  Otherwise, $z$ has at least one child.  Without loss of generality, assume $z$ has a non-empty left subtree $T_l$.  Then the largest node $z'$ in $V(T_l)$ is the largest value in $V(T)$ that is less than $z$. Inductively remove $z'$ from $T_l$ to obtain $T_l'$ and make this the left child of $z$.  Now replace $z$ with $z'$ to obtain $T'$.  
  
  That $T'$ is indeed a binary search tree is straightforward to verify.  All that remains is to prove that $\sigma_{T'}(y)$ is a prefix of $\sigma_T(y)$ for every $y\in V(T')$. There are three cases:
  \begin{enumerate}
    \item $y=z'$: Since $z$ is an ancestor of $z'$ in $T$, $\sigma_{T'}(y)=\sigma_T(z)$ is a prefix of $\sigma_T(y)=\sigma_T(z')$.  
    
    \item $y\in V(T)\setminus\{z\}\setminus V(T_l)$: In this case $\sigma_T(y)=\sigma_{T'}(y)$.  
    
    \item $y\in V(T_l')$: In this case, $\sigma_{T'}(y)=\sigma_{T}(z),0,\sigma_{T_l'}(y)$ and $\sigma_T(y)=\sigma_{T}(z),0,\sigma_{T_l}(y)$.  By induction, $\sigma_{T_l'}(y)$ is a prefix of $\sigma_{T_l}(y)$, so $\sigma_{T'}(y)$ is a prefix of $\sigma_T(y)$. \qedhere
  \end{enumerate}
\end{proof}

\lemref{deletion-prefix} is useful because it means that, for any particular node of $y$ of $T_x$, the net effect of all the deletions performed when moving from $T_x$ to $T_{x+1}$ on $\sigma(y)$ can be encoded by a single integer in the range $\{0,\ldots,h(T(x))\}$.  Using the $\gamma$-code, this requires only $O(\log h(T_x))$ bits.  If $T$ is at-all balanced, this is only $O(\log\log n)$ bits.

\subsection{Bulk Insertions}


\begin{lem}\lemlabel{chunked-addition}
  For any binary search tree $T$ and any set $Y\subset\R\setminus V(T)$ such that $V(T)$ $a$-chunks $Y$, there exists a binary search tree $T'$ with $V(T')=V(T)\cup Y$ that is a supergraph of $T$ and such that $h(T')\le h(T)+1+\log a$.
\end{lem}

\begin{proof}
  Search for each element $y\in Y$ in $T$ until the search path falls out of $T$.  This would be the natural place to add $y$ as a leaf to $T$.  This partitions $Y$ into $r:=|T|+1$ sets $Y_1,\ldots,Y_r$ and, since $V(T)$ $a$-chunks $Y$, each $Y_i$ has size at most $a$.  For each $Y_i$ construct a binary search tree $T_i$ of height at most $\log a$ and attach this to the appropriate location in $T$ to obtain $T'$.
\end{proof}

\lemref{chunked-addition} is useful because the set of values $Y:=L_{x+1}\setminus L_x$ that are present in $T_{x+1}$ but not in $T_x$ are $a$-chunked by $L_x\cap L_{x+1}$. Therefore, we can perform all the additions required to move from $T_x$ to $T_{x+1}$ in such a way that $\sigma_{T_x}(y)=\sigma_{T_{x+1}}(y)$ for every $y\in V_x\cap V_{x+1}$ and $h(T_{x+1})\le h(T_x)+1+\log a$.  

\subsection{Tree Splitting}

\lemref{deletion-prefix} and \lemref{chunked-addition} help control the structure of the trees $T_1,\ldots,T_m$.  However, by themselves, they are not enough to ensure that $h(T_x)=\log|T_x|+o(\log n)$, even if $T_1$ is perfectly balanced.  Indeed, \lemref{deletion-prefix} does not ensure that the height of $T$ decreases even after many deletions.  Similarly, \lemref{chunked-addition} allows the height of $T$ to increase by $1+\log a$ even in the case where only $a$ additional elements are inserted.  

In this section, we introduce what (to our knowledge) is a novel form of rebalancing that ensures that $h(T_x)=\log|T_x|+o(\log n)$.  Standard forms of rebalancing, including height-balancing, weight-balancing, and partial rebuilding seem not to be applicable in our setting because we have unusual requirements.  In particular, the requirement $h(T_x)=\log|T_x|+o(\log n)$ is quite stringent most standard binary search trees guarantee only $h(T)\le c\log |T|$ for some some constant $c>1$.  Even more exotic is that the updates come in linear-sized batches, where batch $x$ consists of the deletions $V_x\setminus V_{x+1}$ and the insertions $V_{x+1}\setminus V_x$, and we require that there exists a simple relationship between $\sigma_{T_x}(y)$ and $\sigma_{T_{x+1}}(y)$ for each $y\in V_x\cap V_{x+1}$.     

We begin with the following simple lemma:

\begin{lem}\lemlabel{split}
  Let $T$ be a binary search tree and let $y$ be any node of $T$.  Then there exists a binary search tree $T'$ with $h(T')\le h(T)+1$, $V(T')=V(T)$ whose root is $y$ and such that, for each node $z\in V(T')$, $\sigma_{T'}(z)$ is obtained by replacing a prefix of $\sigma_{T}(z)$ with a binary string from the set $\{\varepsilon\}\cup \{01^r:r\in\{0,\ldots,h(T)\}\cup \{10^r:r\in\{0,\ldots,h(T)\}$.  
\end{lem}

\begin{proof}
Proof by (crappy) illustration:
  \begin{center}
    \includegraphics[width=.6\textwidth]{images/split}
  \end{center}
\end{proof}

\lemref{split} allows us to perform a perfect split at the root of $T$ and still maintain an $O(\log h(T))$-length description of the changes required to obtain $\sigma_{T'}(z)$ from $\sigma_T(z)$.  A useful fact about \lemref{split} is that the left and right subtree of $T'$ each have height at most $h(T)$.
The following lemma uses \lemref{split} recursively:

\begin{lem}\lemlabel{mini-split}
  Let $T$ be a binary search tree and let $y_1<\cdots<y_c$ be a set of nodes in $T$. Then there exists a binary search tree $T'$ with $V(T')=V(T)$, $h(T')\le h(T)+\log c$, and in which $T'[\{y_1,\ldots,y_c\}]$ is a tree of height at most $\log c$ that contains the root of $T'$ and such that, for each node $z\in V(T')$, there is a binary string of length $O((1+\log c)\log h(T))$ that describes how to convert $\sigma_T(z)$ into $\sigma_{T'}(z)$.  Furthermore, each tree in the forest $T'-\{y_1,\ldots,y_c\}$ is a tree of height at most $h(T)$.
\end{lem}

\begin{proof}
  The proof is by induction on $c$.  If $c=0$, the statement is trivially true with $T':=T$.  If $c\ge 1$,  apply \lemref{split} to $y_{\lceil c/2\rceil}$ to obtain a tree $T_\times$ rooted at at $y_{\lceil c/2\rceil}$.  Next apply induction on the left subtree of $T_\times$ with the set $y_1,\ldots,y_{\lceil c/2\rceil -1}$ and apply induction on the right subtree of $T_\times$ with the set $y_{\lceil c/2\rceil +1},\ldots,y_c$.  Let $T'$ be the tree whose root is $y_{\lceil c/2\rceil}$ and whose left and right subtrees are the result of these two applications of induction.
  
  It is straitforward to check that $h(T')\le h(T)+\log c)$ and that $T[\{y_1,\ldots,y_c\}]$ is a tree of height at most $\log c$ that contains the root of $T'$.  The condition involving $\sigma_T(y)$ and $\sigma_{T'}(y)$ follows from the fact that any node $y\in V(T)$ is involved in at most $\log c$ inductive calls and each such call involves one application of \lemref{split}.  The effect of each application of \lemref{split} on $\sigma(y)$ can be recorded by $O(\log h(T))$ bits for a total of $O((1+\log c)\log h(T))$ bits.  Finally, the condition involving the heights of trees in $T'-\{y_1,\ldots,y_c\}$ follows from the fact that the depth any node $z$ only increases (by 1) for each element of $y_1,\ldots,y_c$ on the path from the root of $T'$ to $y$.
\end{proof}

\begin{lem}\lemlabel{multi-split}
  Let $k,c\ge 1$ be integers, and let $T$ be a binary search tree.  Then there is a binary search tree $T'$ with $V(T')=V(T)$ in which
  \begin{compactenum}
    \item $h(T')\le h(T)+1$; 

    \item  each of the subtrees $T_i'$, $i\in\{1,\ldots,m'\}$ rooted at a depth-$(k+1)$ node of $T'$ has size at most $|T|/2^k$; and
    
    \item for each $y\in V(T)$, there exists an $O(k\log h(T))$-bit description of the changes required to create $\sigma_{T'}(y)$ from $\sigma_T(y)$.
  \end{compactenum}
\end{lem}

\begin{proof}
  Let $Z\subset V(T)$ be the set of at most $2^k-1$ nodes of $T$ of depth less than $k$.  Then $T-Z$ is a forest consisting of $m\le 2^{k}$ trees $T_1,\ldots,T_m$.  Each such tree $T_i$ has height at most $h(T)-k$.
  
  Select the nodes $Y:=\{y_1,\ldots,y_{2^k}-1\}$ of $T$ where each $y_j$ has rank $\lfloor j|T|/2^k\rfloor$ in the set $V(T)$.\footnote{For a finite $X\subset\R$, the \emph{rank} of $x\in S$ is $|\{x'\in S: x'<x\}$.}  For each $j\in\{1,\ldots,m\}$, apply \lemref{mini-split} to the subtree $T_j$ with the at most $2^k$ values $Y\cap V(T_j)$ to obtain a new subtree $T_{j}'$.  Let $T^@$ be the tree obtained by replacing each of $T_1,\ldots,T_m$ with $T_1',\ldots,T_m'$, respectively.
  
  Now, $Z\cup Y$ has size at most $2(2^{k}-1)< 2^k-1$ and $T^@[Z\cup Y]$ is a connected subtree that contains the root of $T^@$.  Construct the tree $T'$ by building a complete binary search tree $T'_0$ of height at most $k$ with $V(T_0')=Z\cup Y$ and then attaching each tree in the forest $T^@-(Z\cup Y)$ to the appropriate location in $T'_0$.  Since $T'_0$ has height at most $k$ and each tree in this forest has height at most $h(T)-k$, $h(T')\le h(T)+1$.
  
  For the final condition, observe that, for each each node $y\in (Z\cup Y)\cap V(T_i)$ we can obtain $\sigma_{T^@}(y)$ from an additional $O(k\log h(T))$ bits as described in \lemref{mini-split}. From $\sigma_{T^@}(y)$ we can obtain $\sigma_{T'}(y)$ be deleting a prefix whose length can be specified using $O(\log h(T))$ bits and replace this with a sequence of at most $k+1$ bits describing a path from the root of $T'_0$ to an external node.
\end{proof}

\subsection{Rebalancing}

We can now describe the sequence of binary search trees $T_1,\ldots,T_m$ satisfying (PR1)--(PR4) required by the labelling scheme.  Recall that $V(T_i)=V_{i}$ where $V_1,\ldots,V_m$ are the sets described by \lemref{fractional}.  The easiest way to describe these trees is in terms of a binary search tree $T$ that supports two operations:
\begin{enumerate}
  \item \emph{bulk-deletion}: in which a set $D:=V_{i}\setminus V_{i+1}$ of at most $|T|(1-2/a)$ values are removed from $T$. The set $V_{i+1}=V(T)\setminus D$ of remaining values $a$-chunks $D$.  
  \pnote{NOTE: We don't use the $a$-chunking property, except for the lower-bound it gives on $|V_{i+1}|$.}
  \item \emph{bulk-insertion}: in which a set $I:=V_{i+1}\setminus V_i$ of at most $2a|T|$ new values are added into $T$.  The set $I$ of newly added values are $a$-chunked by $V(T)$.
\end{enumerate}
First we consider the effect of a pair of bulk-deletion/bulk-insertion operations on the height of $T$.

By \lemref{deletion-prefix}, each bulk-deletion does not increase $h(T)$.  Thus, if we start with a tree $T_1^\times$ and peform one bulk-deletion and one bulk-insertion then, 
by \lemref{chunked-addition}, the resulting tree $T_2$ has height
\[
   h(T_2) \le h(T_1^\times)+\log a \enspace .
\]
Thus, a single round of bulk-insertion/bulk-deletion does not increase the height of $T$ by more than $\log a$.  The trick is to devise a rebalancing scheme that only allows this to continue for $o(\log n)$ rounds before guaranteeing that the tree returns to a more balanced state.

We will use a rebalancing scheme that is parameterized by an integer parameter $k\in o(\log n)$ to be discussed shortly.  This scheme guarantees that, for each $i\in\{1,\ldots,\lceil\log|T_i|/(k-\log(2a))\rceil+1\}$, 
\begin{enumerate}[(B1)]
  \item $h(T_i)\le h(T_1) + (i-1)(1+\log a)$;
  \item each subtree of $T_i$ rooted at a node of depth $(i-1)(k+1)$ has size at most $|T_1|(2a/2^k)^{i-1}$.
\end{enumerate}

The invariants (B1) and (B2) actually provide two upper bounds on the height of $h(T_i)$.  Let
\[
   i^* := \left\lceil \frac{\log|T_1|}{k-\log(2a)}\right\rceil + 1
\]
and observe that
\[
   |T_{1}|\left(\frac{2a}{2^k}\right)^{i^*-1} \le 1 \enspace .
\]
So, by (B2) every subtree of $T_{i^*}$ of depth $(i^*-1)(k+1)$ has size at most 1.  A subtree of size 1 has height 0.  Therefore,
\begin{align*}
  h(T_{i^*}) & \le (i^*-1)(k+1) \\
  & = \frac{(k+1)\log|T_1|}{k-\log(2a)} + k+1 \\
  & \le \frac{(k+1)(\log |T_{i^*}| + (i^*-1)\log(2a))}{k-\log(2a)} + k+1 \\
  & \le \log|T_{i^*}| + O(k + k^{-1}\log |T_i|) \\
  & \le \log |T_{i^*}| + O(k + k^{-1}\log n)
\end{align*}

Let $r_1=h(T_1)-\log |T_1|$ and note that $|T_i|\ge |T_1|/(2a)^{i-1}$ so, for $i\in\{1,\ldots,i^*\}$, (B1) gives the upper bound
\begin{align}
     h(T_i) & \le h(T_1) + (i-1)(1+\log a) \nonumber \\
            &= \log|T_1| + (i-1)(1+\log a) + r_1 \nonumber \\
            &\le \log |T_i| + (i-1)(1+2\log a) + r_1 \nonumber \\
            &\le \log |T_i| + (i^*-1)(1+2\log a) + r_1 \nonumber \\
            &\le \log |T_i| + O(k^{-1}\log|T_i|) + r_1 \nonumber \\
            &\le \log |T_i| + O(k^{-1}\log n) + r_1 \enspace .
\end{align}

Therefore, if $r_1\in o(\log n)$ and $k\in\omega_{n}(1)$, then
\[  h(T_i) \le \log |T_i| + o(\log n) \]
for all $i\in\{1,\ldots,i^*\}$.  At the end of this process, the tree $T_{i^*}$ has height
\[
    h(T_{i^*})= \log |T_{i^*}| + O(k + (\log n)/k) := \log |T_{i^*}| + r_{i^*}
\]
where $r_{i^*}:=h(T_{i^*})-\log|T_{i^*}|\in O(k + k^{-1}\log n)$.  At this point we continue as if $T_{i^*}$ were the first tree in the sequence and this is valid since $r_{i^*}\in o(\log n)$.  This establishes Property~(PR2) for the sequence of trees $T_1,\ldots,T_m$.  

It remains is to describe the rebalancing scheme that guarantees (B1) and (B2).  The scheme is simple: For each $i\in\{1,\ldots,i^*-1\}$,
\begin{enumerate}[(S1)]
  \item Apply \lemref{multi-split} to each of the at most $2^{(i-2)(k+1)}$ subtrees of $T_i$ rooted at nodes of depth $(i-2)(k+1)$ to obtain a new tree $T_i'$.
  \item Perform the bulk-insert operations in $I_i:=V_{i+1}\setminus V_i$ on $T_i'$ to obtain the new tree $T_i''$.
  \item Perform the bulk-delete operations in $D_i:=V_{i}\setminus V_{i+1}$ on $T_i''$ to obtain the new tree $T_{i+1}$.
\end{enumerate}

The proof that these operations preserve invariants (B1) and (B2) is by induction on $i$.  For the base case $i=1$, both properties are trivial: (B1) asserts that $h(T_1)\le h(T_1)$ and (B2) asserts that the subtree of $T_1$ rooted at the root of $T_1$ has size at most $|T_1|$.

For the inductive step, we assume invariants (B1) and (B2) hold for $T_{i-1}$ and prove that they hold for $T_{i}$, $i\ge 2$.  First we establish (B1) as follows:
\begin{align*}  
  h(T_{i}) & \le h(T_{i-1}'') & \text{(by \lemref{deletion-prefix})} \\
          & \le h(T_{i-1}') + \log a & \text{(by \lemref{chunked-addition})} \\
          & \le h(T_{i-1}) + 1 + \log a & \text{(by \lemref{multi-split})} \\
          & \le h(T_1) + (i-2)(1+\log a) + 1 + \log a & \text{(by (B1) for $T_{i-1}$)}\\
          & = h(T_1) + (i-1)(1+\log a) \enspace ,
\end{align*}
as required.

Next we establish (B2).  By (B2) applied to $T_{i-1}$, every subtree of $T_{i-1}$ rooted at a node of depth $(i-2)(k+1)$ has size at most $|T_{1}|(2a/2^k)^{i-2}$.  Step (S1) then ensures that every subtree of $T_{i-1}'$ rooted at a node of depth $(i-1)(k+1)$ has size at most $|T_{1}|(2a/2^k)^{i-2}/2^k$.  The bulk addition in (S2) increases the size of each subtree by a factor of at most $2a$, so every subtree of $T_{i-1}''$ rooted at a node of depth $(i-1)(k+1)$ has size at most $|T_{1}|(2a/2^k)^{i-1} $.
Finally, the bulk-deletion in (S3) does not increase the size of any subtree, so every subtree of $T_{i}$ rooted at a node of depth $(i-1)(k+1)$ has size at most $|T_{1}|(2a/2^k)^{i-1}$, as required.


\subsection{The $\nu$ Code}

In the previous section we established that the sequence $T_1,\ldots,T_m$ of trees satisfies Property~(PR2) since $|\sigma_{T_i}(y)|\le h(T_i)\le \log |T_i|+O(k+k^{-1}\log n)$.  These trees also satisfy Properties~(PR1) and (PR3) since, for each $i\in\{1,\ldots,m\}$, $V(T_i)=V_i$ is the set described in \lemref{fractional}.  Thus, all that remains is to describe the codes $\nu_x(y)$ for each $x\in\{1,\ldots,m-1\}$ and $y\in V_x\cap V_{x+1}$ that satisfy Property~(PR4).

The purpose of $\nu_x(y)$ is to provide instructions on how to modify $\sigma_{T_i}(y)$ to obtain $\sigma_{T_{i+1}}(y)$.  Therefore we consider the three steps (S1)--(S3) that convert $T_i$ into $T_{i+1}$.  
\begin{enumerate}[(S1)]
  \item applies \lemref{multi-split} to each subtree of $T_i$ at depth $(i-1)(k+1)$ to obtain a new $T_i'$.  Every node $y\in V(T_y)$ is contained in at most one such subtree $T_y$ that becomes a subtree $T_y'$ of $T_i'$.  For each such node $y$, we include the integer $(i-1)(k+1)$ in $\nu_i(y)$. \lemref{multi-split} describes $O(k\log h(T))=O(k\log\log n)$ bits that make it possible to recover $\sigma_{T_y'}(y)$ from $\sigma_{T_y}(y)$.  To get $\sigma_{T_i'}(y)$ we keep the first $(i-1)(k+1)$ bits of $\sigma_{T_i}(y)$ and append $\sigma_{T_y'}(y)$.
  
  \item applies \lemref{chunked-addition} (bulk-insertion) to $T_{i}'$ to obtain $T_{i}''$.  This has no effect on any existing signature.  That is, $\sigma_{T_i'}(y)=\sigma_{T_{i}''}(y)$ for every $y\in V(T_i)$.
  
  \item applies \lemref{deletion-prefix} (bulk-deletion) to $T_{i}''$ to obtain $T_{i+1}$. \lemref{deletion-prefix} shows that, for each $y\in V_{i+1}$, $\sigma_{T_{i+1}}(y)$ can be obtained by removing a suffix from $\sigma_{T_i''}(y)$.  For each $y\in V_{i+1}$, the length of this suffix, encoded using $O(\log\log n)$ bits is included in $\nu_{i}(y)$.
\end{enumerate}

This establishes, Property~(PR4) of $T_1,\ldots,T_m$ where each code $\nu_i(y)$ has length $O(k\log\log n)$. The optimal choice of $k=\left\lceil\sqrt{\log n/\log\log n}\right\rceil$, which results each vertex of the $n$-vertex subgraph $G$ of $P_1\boxtimes P_2$ being assigned a label of length $\log n + O(\sqrt{\log n\log\log n})$.

\begin{thm}
  There exists an adjacency-labelling scheme for subgraphs of $P_1\boxtimes P_2$ in which the vertices of any $n$-vertex subgraph $G$ of $P\boxtimes P$ are assigned labels of length at most $\log n + O(\sqrt{\log n\log\log n})$.
\end{thm}

Phew!
  
\section{Subgraphs of $H\boxtimes P$}

\begin{verbatim}
Hi All,

Today's progress report:

1. I spent time carefully writing the P*P solution---in particular
finishing up the bulk-insertions/deletions and rebalancing parts.  We
get label length log n + O(sqrt(log n loglog n).
http://cglab.ca/~morin/publications/drafts/labelling/

2. Vida and I spent some time thinking about the generalization to H*P
where H is a k-tree, and think that most of the work is done already
by the P*P solution.  Here's the idea:

H is a subgraph of an interval graph of thickness k*log n, so let's
assume the nodes of H are actually real intervals that are properly
coloured with klog n colours.

For any subset S of V(H) there is a set X of at most |S| real numbers
(I'll call these points) so that every v in S contains at least one
point in X.  We say that X stabs S.

Our subgraph of H*P actually contains a sequence S_1,..,S_m of subsets
of V(H) of total size n.  We can greedily compute a sequence of point
sets  X_1,...,X_m where X_i stabs S_i and there is a function f_i:S_i->x_i
such that f_i(v) is a point that stabs v.  These point sets are
constructed lazily so that, if v is in S_i\cap S_{i+1}, then f_i(v)=f_{i+1}(v). 
The only points in X_i that are not in X_{i+1} are those that are unnecessary: those x in X_i such that there is no v in S_i with f(v)=x.

This guarantees that |X_i|<=|S_i|.

Now we're going to use all the machinery we developed in Section 3 of
the write-up to make a sequence of binary search trees T_1,..,T_m
where each T_i contains a superset of X_i, the T_i's have linear total
size, the height of T_i is log|T_i| + o(log n) and, for any point x
that appears in T_i and T_{i+1}, there is a o(log n)-bit description
of how to rewrite the root to x path in T_i (a sequence of 0's and
1's) so that it becomes the root to x path in T_{i+1}.

We can also assign a label to each vertex v in S_i of length log n -
log|T_i| so that for v in S_i and w in S_j, label(v) and label(w) tell
us if j-i is {-1, 0, 1, >=2}. So now each vertex v in S_i has log|T_i|
free bits it can still use for its label.

For each interval/vertex v in S_i, we assign v to the highest point 
x_i(v) in T_i that stabs v.  Now for any v in S_i, there is one 
root to leaf path in T_i that contains x(v),x(p_1(v)),..,x(p_k'(v)) where
p_1(v),..,p_k'(v) are the k-tree parents of v that happen to be in
S_i.  So log|T_i| + o(log n) bits plus an additional kloglog n bits is
enough then to recover all the root to x(v) and x(p_i) paths. This
plus a bit more bookkeeping that Cyril described in his email is
enough to test if an edge vw is in E(G) using label(v) and label(w)
provided that v and w are both in S_i.  The only issue that remains is
what to do if v is in S_i and w is in S_{i+1}, since label(v) contains
a path to x_i(v) in T_i and label(w) contains a path to x_{i+1}(v) in
T_{i+1}.  If x_i(v)=x_{i+1}(v) then we're happy: Our solution for P*P
already includes enough information to convert the path to x(v) in T_i
into the path to x(v) in T_{i+1}.

What to do when x_i(v)!= x_{i+1}(v)?  For this, we have to look at why
x_i(v) would change.  This happens because in T_i, x_i(v) was closer
to the root than x_{i+1}(v) but in T_{i+1}, x_{i+1}(v) is closer to
the root than x_i.   How did x_{i+1}(v) get closer to the root in
T_{i+1}?  For that, we have to look at the solution for P*P and how
the binary search trees T_i and T_{i+1} are related.

1. It wasn't because x_{i+1}(v) was inserted in T_{i+1}: Newly
inserted nodes are added as tiny subtrees at the leaves. They're
further from the root than any preexisting node.

2. Maybe it was because some ancestor x of x_{i+1}(v) was deleted so
x_{i+1}(v) took its place, closer to the root.  If so, then the path
to x_{i+1}(v) in T_{i+1}(v) is still a prefix of path to x_i(v) in
T_i, and all we need is to store the length of this prefix so we can
derive the path the root to x_{i+1}(v) path from x_i(v).

3. Maybe it was because we did a rebalancing operation that brought
x_{i+1}(v) closer to the root, overtaking x_i(v).  These rebalancing
operations all use the same basic operation, and this operation is
depicted in the only figure in the paper, which I will now refer to.
In this case, the only nodes on a root-to-leaf path that change
relative order are on the path to the node x that is being moved
closer to the root.  Even then, the relative distance to the root of
these nodes does not change except for nodes a and b where a is on the
"left wall" of the figure and b is on the "right wall".  But if a
stabs v and b stabs v, then the root also stabs v.  So the node
x_{i+1}(v) is the root x in T_{i+1} of subtree being restructured. In
particular, the root to x path in T_{i+1} is a prefix of the root to
x_i(v) path in T_i.  This can also be recorded using O(\log\log n)
bits.

That's it(?!)

Pat
\end{verbatim}
  
  
\bibliographystyle{plain}
\bibliography{labelling}

\end{document}
